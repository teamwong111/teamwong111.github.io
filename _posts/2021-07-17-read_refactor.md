---
layout:     post
title:      "读《重构》"
subtile:    "试图重构《重构》"
date:       2021-07-17 14:00:00
author:     "Wungjz"
header-img: "img/post-bg-2015.jpg"
tags:
    - 阅读
---

> “软件工程类的书籍实在是不会给人以惊喜之感，但也可能是因为我还没有参与过工程. --by wungjz ”


## 前言

今天读了一下《重构》，发出了上面那样的感慨，因为之前也读了一下《架构整洁之道》，所以我说软件工程类的书籍实在是不会给人以惊喜之感，下面我简单阐述《重构》的可能缺点以及一下我读《重构》的笔记吧。

---

## 《重构》的可能缺点

虽然我说《重构》的缺点，但其实我并不是针对《重构》，事实上，以下的缺点可能是所有软件工程类书籍的共有缺点。而出现这样的共有缺点的原因是因为软件工程本质上是实践而不是科学，其中充满了经验主义的“味道”，没有严格而合乎逻辑的演化过程。从瀑布到敏捷再到现在对敏捷的反思，从重开发轻测试到测试驱动开发（TDD）再到对TDD的反思，从中心化到边缘再到中心化，这个领域一直是波浪式前进、螺旋式上升的（其他领域也一样，比如操作系统的微内核和宏内核之争）。正是因为没有帕累托最优的演化，没有哪怕短时间（50 years ？）内的真理（马克思告诉我们没有永恒的真理），所以今天的宴宾客可能明天就会楼塌了，而阐述软件工程的书籍自然就会为了给自己的观点留足提前量而说着一些左右逢源的话。

有点偏题，下面还是说说我认为的《重构》的缺点吧。

1. 书中提供了大量的代码，但是代码并没有高亮，尤其是其Web版书籍也没有高亮，导致读起来很难受。
2. 开篇第一页“在本书第一版中，...，很多人可能要问了：‘影片出租店是什么？’...”，实在是有些啰嗦了（但读到后边就知道这是作者的风格），我也不好评判是好是坏吧，就像我无法评判《the little schemar》的问答体风格的好坏一样。
3. 从第五章开始的大量的重构名录中，许多部分没有正交，尤其是各种相反的重构方法反复的说，不免拖沓，当然也可以认为是从不同角度阐述，但是我个人还是认为过于冗余了。
4. 作者也有一些我认为不好的习惯，比如在分解条件表达式一节中，他提到喜欢用三元运算符重新安排条件语句，而实际上三元运算符是导致代码可读性下降的一个重要原因，这一点在Verilog语言中的Wire型数据上尤其严重。再比如作者提到用卫语句取代嵌套条件表达式，P266举的例子完全可以用if else if else来重构，不需要使用卫语句。

---

## 笔记

因为笔记是为我个人服务的，所以我只会记录一些原句或简要的叙述，如果你希望从我的笔记中学到知识，那可能就错了，还是自己读书才能学到知识，所以我建议还是可以读一下这本书的。

### 1. 重构，第一个示例

#### 1.3 重构的第一步

- 重构之前确保有一组可靠的测试

#### 1.4 分解statement参数

- 小步修改，每次修改完就运行测试（有点像敏捷开发和国产航母开发里的小步快跑快速迭代）
- 修改完成后提交到本地的版本控制系统
- 永远将函数的返回值命名为“result”
- 动态类型语言在命名时跟踪变量的类型
- 临时变量实际上是鼓励你写长而复杂的函数，所以尽量用函数替换临时变量

#### 1.6 拆分计算阶段与格式化阶段

- 重构的早期步骤就是把复杂的代码块分解为更小的单元（那晚期呢？）

#### 1.9 进展：使用多态计算器来提供数据

- 有越多的函数依赖于同一套类型进行多态，这种继承方案就越有益处，这里就是在讲把if+else换成switch+多态，如下

```C++
if (...) {

}
else if (...) {

}

// 利用多态换成

switch(...) {
    case ...: a subclass;
    case ...: a subclass;
}

// 好像表构造的方式更优雅
```

### 2. 重构的原则

#### 2.3 为何重构

- 消除重复代码，我就可以确定所有事物和行为在代码中只表述一次（这样就不会出现这里改了，那没改的情况，这才是消除重复的意义，而不是所谓的减少了多少代码行数）

#### 2.4 何时重构

- 正如老话讲的，事不过三，三则重构
- 添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入
- 有计划的重构应该很少，大部分重构应该使不起眼的、见机行事的

#### 2.5 重构的挑战

- 我建议不要搞细粒度的强代码所有制（防止你没法修改别人写的代码）
- 现代版本控制系统能很好地合并程序文本地复杂修改，但对于代码的语义他们一无所知（所以可以尝试以下改进Git）
- 在使用CI时，每个团队成员每天至少向主线集成一次。这个实践避免了任何分支彼此差异太大
- 数据库重构最好是分散到多次生产发布来完成（不懂）

#### 2.8 重构与性能

- 程序的大半时间都耗费在一小半代码上

#### 2.10 自动化重构

- 不仅能处理文本，还能处理语法树，这是IDE相比于编辑器更先进的地方
- 语言服务器，用软件生成语法树，给编辑器提供API

### 3. 代码的坏味道

#### 3.3 过长函数

- 活得最长、最好的程序，函数都比较短
- 如果代码前方有一行注释，就是在提醒你，可以把这段代码换成函数
- 条件表达式和循环常常也是提炼的信号

#### 3.4 过长参数列表

- 使用类可以有效地缩短参数列表

#### 3.13 循环语句

- 函数作为一等公民得到了广泛的支持，所以可以用管道取代循环让这些老古董退休

### 6. 第一组重构

#### 6.3 提炼变量

- 局部变量可以帮助我们讲表达式分解为比较容易管理的形式（yinwang也说过类似的观点）

#### 6.5 改变函数声明

- 先写一句注释描述函数的用途，再把注释变成函数的名字
- 这种重构手法同样适用于已发布API——使用这些API的代码我无权修改（所以说甲方还得有懂代码的人啊）
- 自动化重构工具减少了迁移式的用武之地，同时也使迁移式做法更加高效

#### 6.6 封装变量

- 如果想搬迁一处被广泛使用的数据，最好先以函数封装所有对该数据的访问
- 即便在类内部，也应该通过函数来使用字段——自封装（这确实没必要）
- 不可变性是强大的代码防腐剂（functional赛高）

#### 6.9 函数组合成类

- 通常我更倾向类而非嵌套函数（that's right）
- 在函数为一等公民而类不是的语言里，可以用函数作为对象来实现这个重构（这里应该就是指高阶函数的方法吧）

### 7. 封装

#### 7.2 封装集合

- 任何负责管理集合的类都应该总是返回数据副本

#### 7.3 以对象取代基本类型

- 一旦我发现对某个数据的操作不仅仅局限于打印时，我就会为它创建一个新类

### 8. 搬移特性

#### 8.6 移动语句

- 尽量遵循命令与查询分离原则，这样任何有返回值的函数都不存在副作用

#### 8.7 拆分循环

- 循环本身很少成为性能瓶颈，拆分出来的循环通常还使一些更强大的优化手段变得可能

#### 8.9 移除死代码

- 一旦代码不再被使用，就应该立马删除它（反正有Git可以回滚）

### 9. 重新组织数据

#### 9.1 差分变量

- 很多变量用于保存一段冗长代码的运算结果，这种变量应该只被赋值一次（还是在讲变量不变性的重要性）

#### 9.5 将值对象改为引用对象

- 这一部分讲值对象和引用对象还是很值得探讨的，所以我说一下我的认识吧。
  - 首先，引用对象对于应用级程序来说肯定是要比指针要好的，因为完成了一个封装，没有把对象的位置暴露给程序员。
  - 其次，引用对象避免了重复拷贝，也避免了共享的数据需要更新带来的数据一致性问题，也方便垃圾回收。
  - 但值对象也有自己的好处，那就是不会出现多处更新带来的冲突
  - 因此，我认为在应用级程序语言中，值对象和引用对象都应该保留，使用上如果需要大量更新就用引用，如果是少量更新就用值。

### 10. 简化条件逻辑

#### 10. 3 以卫语句取代嵌套条件表达式

- 条件表达式有两种风格。第一种风格是两个条件分支都是正常行为；第二种风格是有一个条件分支是异常的情况。（但我还是认为一个函数只应该有一个出口）

---

## 总结

这本书我并没有精读，作者也不建议精度，另外正如我最开始说的“但也可能是因为我还没有参与过工程”，所以这种类型的书应该是多次阅读吧，明年的这个时候我会重新读这本书的，如果我还记得的话（doge）。